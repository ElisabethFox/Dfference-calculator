
import _ from 'lodash';

const buildTreeOfDifferences = (obj1, obj2) => {
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    const keys = _.union(keys1, keys2).sort();

    return keys.map((key) => {
          if (_.isObject(obj1[key]) && _.isObject(obj[key])) {
            return { key: { difference: 'nested', value: buildTreeOfDifferences(obj1[key], obj2[key]) } };
          } else if (!Object.hasOwn(obj2, key)) {
            return { key: { difference: 'deleted', value: obj1[key] } };
          } else if (!Object.hasOwn(obj1, key)) {
            return { key: { difference: 'added', value: obj2[key] }};
          } else if (obj1[key] !== obj2[key]) {
            return { key: { difference: 'changed', value1: obj1[key], obj2: data2[key] } };
          } else {
            return { key: { difference: 'unchanged', value: obj1[key] } };
          };
    });
}

export default buildTreeOfDifferences;




const sign =
//знак у нас может быть + или - или просто пробел, так что тут все просто, ничего дополнительного делать не будем, будем вычислять знак в зависимости от типа отличия при формировании строки.

const indent = (depth) => ' '.repeat((depth * 4) - 2);
//если изучить пример вывода из шестого шага, то можно увидеть что отступ зависит от глубины, каждый уровень отступа это 4 пробела, а на последнем уровне два знака нужны под маркер.

const key = 
//тут тоже все просто, так как ключ это всегда простая строка.

const value =
//d зависимости от типа значение может быть простым (строка, число и т.д.) или составным (объект). Тут нам как раз пригодится функция stringify из второго испытания для преобразования значения к строке.

`${indent(depth)}${sign} ${key}: ${stringify(value, depth)}`

// Далее вид этой строки пригодится при проходе по массиву (для этого подойдет простой map или flatMap).
// На каждом шаге в зависимости от типа отличия будем формировать эту строку.
// Разберем типы:
// added - тут все легко, просто подставляем + вместо sign и другие данные из объекта.
// deleted - тут тоже, просто подставляем - вместо sign и другие данные из объекта.
// unchanged - пробел вместо sign и другие данные из объекта.
// changed - а тут интереснее, нам нужна не одна строка а целых две, как будто сразу два типа deleted и added. Можно склеить эти две строки символом переноса строки \n или использовать flatMap вместо map как советуют в подсказке из шестого шага. Если использовать flatMap, то для типа changed можно возвращать не просто строку, а массив с двумя строками, как это работает можно почитать в документации.
// nested - тут еще интереснее, нам нужно вместо value заново запустить проход по дереву отличий увеличив глубину на единицу, как-будто заново вызвать stylish рекурсивно. Но stylish не принимает параметр depth. Поэтому лучше вместо рекурсии применить итеративный подход.
// Разобрались с типами, теперь суммируем все это и получаем содержание модуля stylish:
// Функция indent для формирования отступа.
// Функция stringify для приведения значения к строке.
// Функция stylish для формирования отличия в строковом виде.
// Внутри функции stylish нам понадобится функция iter, которая принимает дерево отличий и глубину и внутри запускает проход по дереву отличий. Возвращать будем результат полученный от iter склеенный в строку между открывающей и закрывающей фигурными скобками.